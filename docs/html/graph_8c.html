<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Parallelize-Tarjan-MPI-CUDA: common/src/graph.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Parallelize-Tarjan-MPI-CUDA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_bdd9a5d540de89e9fe90efdfc6973a4f.html">common</a></li><li class="navelem"><a class="el" href="dir_4e4d22e38ca4e2e8207825ee2d00bc54.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">graph.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file implements the abstract data type graph with adjacency maps. It also contains basic operation on the graph (vertices and edges insert and deletion) as well as specific operations needed by the * * MPI and CUDA algorithms. The file also defines the scc_set data structure which is used to store SCCs found by Tarjan's algorithm as well as operations on this data structure.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;assert.h&gt;</code><br />
<code>#include &lt;stdio.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;time.h&gt;</code><br />
<code>#include &quot;graph.h&quot;</code><br />
<code>#include &quot;khash.h&quot;</code><br />
<code>#include &quot;linkedlist.h&quot;</code><br />
<code>#include &quot;random.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for graph.c:</div>
<div class="dyncontent">
<div class="center"><img src="graph_8c__incl.png" border="0" usemap="#acommon_2src_2graph_8c" alt=""/></div>
<map name="acommon_2src_2graph_8c" id="acommon_2src_2graph_8c">
<area shape="rect" title="This file implements the abstract data type graph with adjacency maps. It also contains basic operati..." alt="" coords="291,5,445,32"/>
<area shape="rect" title=" " alt="" coords="5,80,80,107"/>
<area shape="rect" title=" " alt="" coords="104,80,171,107"/>
<area shape="rect" title=" " alt="" coords="195,80,266,107"/>
<area shape="rect" title=" " alt="" coords="291,80,355,107"/>
<area shape="rect" title=" " alt="" coords="379,80,450,107"/>
<area shape="rect" title=" " alt="" coords="474,80,547,107"/>
<area shape="rect" title=" " alt="" coords="572,80,665,107"/>
<area shape="rect" title=" " alt="" coords="690,80,774,107"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structscc__set__t.html">scc_set_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:abd8bbcfabb3ddef2ccaafb9928a37b95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#abd8bbcfabb3ddef2ccaafb9928a37b95">min</a> (int a, int b)</td></tr>
<tr class="memdesc:abd8bbcfabb3ddef2ccaafb9928a37b95"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes two integers as input and returns the minimum integer.  <a href="graph_8c.html#abd8bbcfabb3ddef2ccaafb9928a37b95">More...</a><br /></td></tr>
<tr class="separator:abd8bbcfabb3ddef2ccaafb9928a37b95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb56aa20d2f47ee35347989c47c38c7b"><td class="memItemLeft" align="right" valign="top">graph_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#acb56aa20d2f47ee35347989c47c38c7b">graph_init</a> ()</td></tr>
<tr class="memdesc:acb56aa20d2f47ee35347989c47c38c7b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function declares and initializes an empty graph_t data structure.  <a href="graph_8c.html#acb56aa20d2f47ee35347989c47c38c7b">More...</a><br /></td></tr>
<tr class="separator:acb56aa20d2f47ee35347989c47c38c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c364ebe0da93e37d279244116905e49"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#a6c364ebe0da93e37d279244116905e49">graph_free</a> (graph_t *G)</td></tr>
<tr class="memdesc:a6c364ebe0da93e37d279244116905e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes as input a graph_t data structure and takes care of deallocating the entire memory occupied by the data structure.  <a href="graph_8c.html#a6c364ebe0da93e37d279244116905e49">More...</a><br /></td></tr>
<tr class="separator:a6c364ebe0da93e37d279244116905e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a675413568799b0a7566348aa77f25d15"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#a675413568799b0a7566348aa77f25d15">graph_get_num_vertex</a> (graph_t *G)</td></tr>
<tr class="memdesc:a675413568799b0a7566348aa77f25d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes as input a graph_t data structure and returns the number of vertices in the graph.  <a href="graph_8c.html#a675413568799b0a7566348aa77f25d15">More...</a><br /></td></tr>
<tr class="separator:a675413568799b0a7566348aa77f25d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e2ce4d852eac3d59f53edd8983e8c1b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#a5e2ce4d852eac3d59f53edd8983e8c1b">graph_insert_vertex</a> (graph_t *G, int v)</td></tr>
<tr class="memdesc:a5e2ce4d852eac3d59f53edd8983e8c1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes as input a graph_t data structure and a vertex v; it takes care of inserting the vertex v within the graph.  <a href="graph_8c.html#a5e2ce4d852eac3d59f53edd8983e8c1b">More...</a><br /></td></tr>
<tr class="separator:a5e2ce4d852eac3d59f53edd8983e8c1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9031f7f1870c39cc2cba0aa5608058d8"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#a9031f7f1870c39cc2cba0aa5608058d8">graph_insert_edge</a> (graph_t *G, int u, int v)</td></tr>
<tr class="memdesc:a9031f7f1870c39cc2cba0aa5608058d8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes as input a graph_t data structure and two vertices u and v. It takes care of inserting an edge from vertex u to vertex v of the graph. <br  />
 Throws an error is the edge already exists.  <a href="graph_8c.html#a9031f7f1870c39cc2cba0aa5608058d8">More...</a><br /></td></tr>
<tr class="separator:a9031f7f1870c39cc2cba0aa5608058d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e77b2c8fde09a7f5ba0516bda570d13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#a5e77b2c8fde09a7f5ba0516bda570d13">graph_delete_edge</a> (graph_t *G, int u, int v)</td></tr>
<tr class="memdesc:a5e77b2c8fde09a7f5ba0516bda570d13"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes as input a graph_t data structure and two vertices u and v. It deletes the edge from the node u to the node v if it exists. Otherwise does nothing.  <a href="graph_8c.html#a5e77b2c8fde09a7f5ba0516bda570d13">More...</a><br /></td></tr>
<tr class="separator:a5e77b2c8fde09a7f5ba0516bda570d13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5f98c1011c7e0f02f3ddfdfd04b557b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#ac5f98c1011c7e0f02f3ddfdfd04b557b">graph_delete_vertex</a> (graph_t *G, int v)</td></tr>
<tr class="memdesc:ac5f98c1011c7e0f02f3ddfdfd04b557b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes as input a graph_t data structure and a vertex v. It deletes the vertex v and every edge incident on the vertex.  <a href="graph_8c.html#ac5f98c1011c7e0f02f3ddfdfd04b557b">More...</a><br /></td></tr>
<tr class="separator:ac5f98c1011c7e0f02f3ddfdfd04b557b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab67410d3c53f6f1f92908be8a90ad995"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#ab67410d3c53f6f1f92908be8a90ad995">graph_tarjan_helper</a> (graph_t *G, int node, khash_t(m32) *disc, khash_t(m32) *low, <a class="el" href="structlinkedlist__int.html">linkedlist_int</a> *stack, khash_t(m32) *stackMember, int *time, array_int *result)</td></tr>
<tr class="memdesc:ab67410d3c53f6f1f92908be8a90ad995"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is an helper function for <a class="el" href="graph_8c.html#a7889de5b4031ad8100fa6ac37d8392f6" title="This function is a Tarjan&#39;s algorithm implementation using recursion.   This is a modified version of...">graph_tarjan()</a>. For more info see documentation for <a class="el" href="graph_8c.html#a7889de5b4031ad8100fa6ac37d8392f6" title="This function is a Tarjan&#39;s algorithm implementation using recursion.   This is a modified version of...">graph_tarjan()</a>.  <a href="graph_8c.html#ab67410d3c53f6f1f92908be8a90ad995">More...</a><br /></td></tr>
<tr class="separator:ab67410d3c53f6f1f92908be8a90ad995"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7889de5b4031ad8100fa6ac37d8392f6"><td class="memItemLeft" align="right" valign="top">array_int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#a7889de5b4031ad8100fa6ac37d8392f6">graph_tarjan</a> (graph_t *G)</td></tr>
<tr class="memdesc:a7889de5b4031ad8100fa6ac37d8392f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is a Tarjan's algorithm implementation using recursion. <br  />
 This is a modified version of the algorithm on the geeksforgeeks.com website. <br  />
 The main differences are: <br  />
 - disc, low and stackMember are now hash tables because we remove the hypotesis that vertex ids go from 0 to N-1: <br  />
 when working on a subgraph (as a slave process), there are no guarantees on the order nor continuity of the vertex ids. <br  />
 Using hash tables instead of arrays we save a lot of memory. <br  />
 - we remove the hypotesis that every vertex in an adjacency map exists in the graph. This is also caused by executions <br  />
 on subgraphs of a given graph.  <a href="graph_8c.html#a7889de5b4031ad8100fa6ac37d8392f6">More...</a><br /></td></tr>
<tr class="separator:a7889de5b4031ad8100fa6ac37d8392f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa167e922a8e42481edb364dd723eb3d4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#aa167e922a8e42481edb364dd723eb3d4">graph_tarjan_foreach_helper</a> (graph_t *G, int node, khash_t(m32) *disc, khash_t(m32) *low, <a class="el" href="structlinkedlist__int.html">linkedlist_int</a> *stack, khash_t(m32) *stackMember, int *time, array_int *scc, void(*f)(array_int *))</td></tr>
<tr class="memdesc:aa167e922a8e42481edb364dd723eb3d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is an helper function for <a class="el" href="graph_8c.html#adb71a3e52b70daf9a1f91efced7fd1a5" title="This function takes as input a graph and a callback function f. It finds all the SCCs in the graph an...">graph_tarjan_foreach()</a>. For more info see documentation for <a class="el" href="graph_8c.html#adb71a3e52b70daf9a1f91efced7fd1a5" title="This function takes as input a graph and a callback function f. It finds all the SCCs in the graph an...">graph_tarjan_foreach()</a>.  <a href="graph_8c.html#aa167e922a8e42481edb364dd723eb3d4">More...</a><br /></td></tr>
<tr class="separator:aa167e922a8e42481edb364dd723eb3d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb71a3e52b70daf9a1f91efced7fd1a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#adb71a3e52b70daf9a1f91efced7fd1a5">graph_tarjan_foreach</a> (graph_t *G, void(*f)(array_int *))</td></tr>
<tr class="memdesc:adb71a3e52b70daf9a1f91efced7fd1a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes as input a graph and a callback function f. It finds all the SCCs in the graph and each time it finds one it calls the callback function f on the SCC.  <a href="graph_8c.html#adb71a3e52b70daf9a1f91efced7fd1a5">More...</a><br /></td></tr>
<tr class="separator:adb71a3e52b70daf9a1f91efced7fd1a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3873eaea6c1f17fa7028b7946872600d"><td class="memItemLeft" align="right" valign="top">array_int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#a3873eaea6c1f17fa7028b7946872600d">graph_serialize</a> (graph_t *G, int n, khint_t *bucket)</td></tr>
<tr class="memdesc:a3873eaea6c1f17fa7028b7946872600d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes as input a graph, the number of vertices to be serialized n, and a variable to store the reference to the adicence map. <br  />
 The function returns an array of integers representing the serialization of the first n vertices of the graph. <br  />
 In other words, we go from a representation using pointers to a representation that uses integers only.  <a href="graph_8c.html#a3873eaea6c1f17fa7028b7946872600d">More...</a><br /></td></tr>
<tr class="separator:a3873eaea6c1f17fa7028b7946872600d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e0eca0161365f9770e5d45c834cf6d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#ae8e0eca0161365f9770e5d45c834cf6d">graph_deserialize</a> (graph_t *G, array_int *buff)</td></tr>
<tr class="memdesc:ae8e0eca0161365f9770e5d45c834cf6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes as input an array representing a deserialized graph and a reference to a graph. <br  />
 The function transforms the serialized representation of the graph to a graph_t representation via pointers on which all library operations are defined.  <a href="graph_8c.html#ae8e0eca0161365f9770e5d45c834cf6d">More...</a><br /></td></tr>
<tr class="separator:ae8e0eca0161365f9770e5d45c834cf6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae33cfb273887bd4349d2e42b4064e2d2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#ae33cfb273887bd4349d2e42b4064e2d2">graph_save_to_file</a> (graph_t *G, char *filename)</td></tr>
<tr class="memdesc:ae33cfb273887bd4349d2e42b4064e2d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes as input a graph and a string. It serializes the input graph and stores it on a binary file.  <a href="graph_8c.html#ae33cfb273887bd4349d2e42b4064e2d2">More...</a><br /></td></tr>
<tr class="separator:ae33cfb273887bd4349d2e42b4064e2d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af05df5d8c6999573ba0e334c7f6ae513"><td class="memItemLeft" align="right" valign="top">graph_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#af05df5d8c6999573ba0e334c7f6ae513">graph_load_from_file</a> (char *filename)</td></tr>
<tr class="memdesc:af05df5d8c6999573ba0e334c7f6ae513"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a string as input. It extracts a serialized graph from a file and returns a graph in the graph_t format.  <a href="graph_8c.html#af05df5d8c6999573ba0e334c7f6ae513">More...</a><br /></td></tr>
<tr class="separator:af05df5d8c6999573ba0e334c7f6ae513"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed97650c201c27efbe59c6f2717504c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#a0ed97650c201c27efbe59c6f2717504c">graph_merge_vertices</a> (graph_t *G, int dest, array_int *src)</td></tr>
<tr class="memdesc:a0ed97650c201c27efbe59c6f2717504c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes as input graph, a vertex identifier 'dest' and an array of vertices. It merges all vertices in the array into the vertex 'dest'.  <a href="graph_8c.html#a0ed97650c201c27efbe59c6f2717504c">More...</a><br /></td></tr>
<tr class="separator:a0ed97650c201c27efbe59c6f2717504c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c8eef1d5e51a9ade0a654f9ad5c685b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#a9c8eef1d5e51a9ade0a654f9ad5c685b">graph_merge</a> (graph_t *to, graph_t *from, double p)</td></tr>
<tr class="memdesc:a9c8eef1d5e51a9ade0a654f9ad5c685b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge 2 graph and the merged graph is in graph_t * to.  <a href="graph_8c.html#a9c8eef1d5e51a9ade0a654f9ad5c685b">More...</a><br /></td></tr>
<tr class="separator:a9c8eef1d5e51a9ade0a654f9ad5c685b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac919cab75554fcb6dd20f1c5607c68e7"><td class="memItemLeft" align="right" valign="top">graph_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#ac919cab75554fcb6dd20f1c5607c68e7">graph_random</a> (int max_n_node, int mean_edges, double variance_edges)</td></tr>
<tr class="memdesc:ac919cab75554fcb6dd20f1c5607c68e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a random graph with max_n_node node and each node have mean number of edge with a variance_edge  <a href="graph_8c.html#ac919cab75554fcb6dd20f1c5607c68e7">More...</a><br /></td></tr>
<tr class="separator:ac919cab75554fcb6dd20f1c5607c68e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08acc1ae6d4796ac961a68dd767233b2"><td class="memItemLeft" align="right" valign="top">graph_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#a08acc1ae6d4796ac961a68dd767233b2">graph_fully_connected_disconnected</a> (int max_n_node, int isFullyConnected)</td></tr>
<tr class="memdesc:a08acc1ae6d4796ac961a68dd767233b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">create a graph fully connected or fully disconnected with max_n_node  <a href="graph_8c.html#a08acc1ae6d4796ac961a68dd767233b2">More...</a><br /></td></tr>
<tr class="separator:a08acc1ae6d4796ac961a68dd767233b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5362c8bcda308f3fb35f7262afb05396"><td class="memItemLeft" align="right" valign="top">graph_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#a5362c8bcda308f3fb35f7262afb05396">graph_copy</a> (graph_t *from)</td></tr>
<tr class="memdesc:a5362c8bcda308f3fb35f7262afb05396"><td class="mdescLeft">&#160;</td><td class="mdescRight">geneate a copy of a graph  <a href="graph_8c.html#a5362c8bcda308f3fb35f7262afb05396">More...</a><br /></td></tr>
<tr class="separator:a5362c8bcda308f3fb35f7262afb05396"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa8e50b85caf53ed334f81361bd9c19d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#aaa8e50b85caf53ed334f81361bd9c19d">graph_print_debug</a> (graph_t *G)</td></tr>
<tr class="memdesc:aaa8e50b85caf53ed334f81361bd9c19d"><td class="mdescLeft">&#160;</td><td class="mdescRight">print on standard output graph in input: number of edged, for earch line node -&gt; adjacency list and node-&gt; inverted adjacency list  <a href="graph_8c.html#aaa8e50b85caf53ed334f81361bd9c19d">More...</a><br /></td></tr>
<tr class="separator:aaa8e50b85caf53ed334f81361bd9c19d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e1742aecae1a04047d8206cc2d95c48"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structscc__set__t.html">scc_set_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#a5e1742aecae1a04047d8206cc2d95c48">scc_set_init</a> ()</td></tr>
<tr class="memdesc:a5e1742aecae1a04047d8206cc2d95c48"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initialize a new scc_set.  <a href="graph_8c.html#a5e1742aecae1a04047d8206cc2d95c48">More...</a><br /></td></tr>
<tr class="separator:a5e1742aecae1a04047d8206cc2d95c48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c6cfd0e1a260549cffd6e1dc95a48b2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#a8c6cfd0e1a260549cffd6e1dc95a48b2">scc_set_free</a> (<a class="el" href="structscc__set__t.html">scc_set_t</a> *S)</td></tr>
<tr class="memdesc:a8c6cfd0e1a260549cffd6e1dc95a48b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy an scc_set.  <a href="graph_8c.html#a8c6cfd0e1a260549cffd6e1dc95a48b2">More...</a><br /></td></tr>
<tr class="separator:a8c6cfd0e1a260549cffd6e1dc95a48b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8549c916368233448ccf00534b504749"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#a8549c916368233448ccf00534b504749">scc_set_add</a> (<a class="el" href="structscc__set__t.html">scc_set_t</a> *S, int scc_id, array_int *nodes)</td></tr>
<tr class="memdesc:a8549c916368233448ccf00534b504749"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a new SCC to the set handling merges if needed.  <a href="graph_8c.html#a8549c916368233448ccf00534b504749">More...</a><br /></td></tr>
<tr class="separator:a8549c916368233448ccf00534b504749"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74ea6f1044877da655f14a3a1ce2fb30"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#a74ea6f1044877da655f14a3a1ce2fb30">scc_set_print_debug</a> (<a class="el" href="structscc__set__t.html">scc_set_t</a> *S)</td></tr>
<tr class="memdesc:a74ea6f1044877da655f14a3a1ce2fb30"><td class="mdescLeft">&#160;</td><td class="mdescRight">print an scc_set  <a href="graph_8c.html#a74ea6f1044877da655f14a3a1ce2fb30">More...</a><br /></td></tr>
<tr class="separator:a74ea6f1044877da655f14a3a1ce2fb30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dbb2e7d19233634bfaddc3634a43a68"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#a7dbb2e7d19233634bfaddc3634a43a68">scc_set_merge</a> (<a class="el" href="structscc__set__t.html">scc_set_t</a> *dest, <a class="el" href="structscc__set__t.html">scc_set_t</a> *src)</td></tr>
<tr class="memdesc:a7dbb2e7d19233634bfaddc3634a43a68"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge src scc_set into dest.  <a href="graph_8c.html#a7dbb2e7d19233634bfaddc3634a43a68">More...</a><br /></td></tr>
<tr class="separator:a7dbb2e7d19233634bfaddc3634a43a68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a682977e02dc5974253b0022488fe5468"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#a682977e02dc5974253b0022488fe5468">scc_set_contains</a> (<a class="el" href="structscc__set__t.html">scc_set_t</a> *b, <a class="el" href="structscc__set__t.html">scc_set_t</a> *a)</td></tr>
<tr class="memdesc:a682977e02dc5974253b0022488fe5468"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check if scc set b contains all of scc set a's content.  <a href="graph_8c.html#a682977e02dc5974253b0022488fe5468">More...</a><br /></td></tr>
<tr class="separator:a682977e02dc5974253b0022488fe5468"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c6a48fdae7bd73b1ca4d88f00213a83"><td class="memItemLeft" align="right" valign="top"><a id="a6c6a48fdae7bd73b1ca4d88f00213a83"></a>
array_int *&#160;</td><td class="memItemRight" valign="bottom"><b>scc_set_serialize</b> (<a class="el" href="structscc__set__t.html">scc_set_t</a> *S)</td></tr>
<tr class="separator:a6c6a48fdae7bd73b1ca4d88f00213a83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc68d0a35098cd09c81eef58ac345427"><td class="memItemLeft" align="right" valign="top"><a id="acc68d0a35098cd09c81eef58ac345427"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>scc_set_deserialize</b> (<a class="el" href="structscc__set__t.html">scc_set_t</a> *S, array_int *buff)</td></tr>
<tr class="separator:acc68d0a35098cd09c81eef58ac345427"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a403d34ed9cdcf8b1db1afb0367fb59c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#a403d34ed9cdcf8b1db1afb0367fb59c9">scc_set_save_to_file</a> (<a class="el" href="structscc__set__t.html">scc_set_t</a> *S, char *filename)</td></tr>
<tr class="memdesc:a403d34ed9cdcf8b1db1afb0367fb59c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write scc set to file.  <a href="graph_8c.html#a403d34ed9cdcf8b1db1afb0367fb59c9">More...</a><br /></td></tr>
<tr class="separator:a403d34ed9cdcf8b1db1afb0367fb59c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3ba807e3fbeeed224587d3a609b84b9b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structscc__set__t.html">scc_set_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="graph_8c.html#a3ba807e3fbeeed224587d3a609b84b9b">scc_set_load_from_file</a> (char *filename)</td></tr>
<tr class="memdesc:a3ba807e3fbeeed224587d3a609b84b9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load scc set from file.  <a href="graph_8c.html#a3ba807e3fbeeed224587d3a609b84b9b">More...</a><br /></td></tr>
<tr class="separator:a3ba807e3fbeeed224587d3a609b84b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file implements the abstract data type graph with adjacency maps. It also contains basic operation on the graph (vertices and edges insert and deletion) as well as specific operations needed by the * * MPI and CUDA algorithms. The file also defines the scc_set data structure which is used to store SCCs found by Tarjan's algorithm as well as operations on this data structure. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a5362c8bcda308f3fb35f7262afb05396"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5362c8bcda308f3fb35f7262afb05396">&#9670;&nbsp;</a></span>graph_copy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">graph_t* graph_copy </td>
          <td>(</td>
          <td class="paramtype">graph_t *&#160;</td>
          <td class="paramname"><em>from</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>geneate a copy of a graph </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">from</td><td>graph to be copied </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>graph_t* graph generated </dd></dl>

</div>
</div>
<a id="a5e77b2c8fde09a7f5ba0516bda570d13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e77b2c8fde09a7f5ba0516bda570d13">&#9670;&nbsp;</a></span>graph_delete_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void graph_delete_edge </td>
          <td>(</td>
          <td class="paramtype">graph_t *&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes as input a graph_t data structure and two vertices u and v. It deletes the edge from the node u to the node v if it exists. Otherwise does nothing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>graph data structure. </td></tr>
    <tr><td class="paramname">u</td><td>vertex of the graph. </td></tr>
    <tr><td class="paramname">v</td><td>vertex of the graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac5f98c1011c7e0f02f3ddfdfd04b557b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac5f98c1011c7e0f02f3ddfdfd04b557b">&#9670;&nbsp;</a></span>graph_delete_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void graph_delete_vertex </td>
          <td>(</td>
          <td class="paramtype">graph_t *&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes as input a graph_t data structure and a vertex v. It deletes the vertex v and every edge incident on the vertex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>input graph </td></tr>
    <tr><td class="paramname">v</td><td>vertex to be deleted </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ae8e0eca0161365f9770e5d45c834cf6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e0eca0161365f9770e5d45c834cf6d">&#9670;&nbsp;</a></span>graph_deserialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void graph_deserialize </td>
          <td>(</td>
          <td class="paramtype">graph_t *&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array_int *&#160;</td>
          <td class="paramname"><em>buff</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes as input an array representing a deserialized graph and a reference to a graph. <br  />
 The function transforms the serialized representation of the graph to a graph_t representation via pointers on which all library operations are defined. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>graph data structure. </td></tr>
    <tr><td class="paramname">buff</td><td>array representing a deserialized graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6c364ebe0da93e37d279244116905e49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c364ebe0da93e37d279244116905e49">&#9670;&nbsp;</a></span>graph_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void graph_free </td>
          <td>(</td>
          <td class="paramtype">graph_t *&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes as input a graph_t data structure and takes care of deallocating the entire memory occupied by the data structure. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>graph data structure to be deallocated. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a08acc1ae6d4796ac961a68dd767233b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08acc1ae6d4796ac961a68dd767233b2">&#9670;&nbsp;</a></span>graph_fully_connected_disconnected()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">graph_t* graph_fully_connected_disconnected </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_n_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>isFullyConnected</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a graph fully connected or fully disconnected with max_n_node </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_n_node</td><td>number of node of graph </td></tr>
    <tr><td class="paramname">isFullyConnected</td><td>0 create a fully disconneted graph 1 create a fully connected graph </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>graph_t* graph generated </dd></dl>

</div>
</div>
<a id="a675413568799b0a7566348aa77f25d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a675413568799b0a7566348aa77f25d15">&#9670;&nbsp;</a></span>graph_get_num_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int graph_get_num_vertex </td>
          <td>(</td>
          <td class="paramtype">graph_t *&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes as input a graph_t data structure and returns the number of vertices in the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>graph data structure of which we want to know the number of vertices. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>int. </dd></dl>

</div>
</div>
<a id="acb56aa20d2f47ee35347989c47c38c7b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb56aa20d2f47ee35347989c47c38c7b">&#9670;&nbsp;</a></span>graph_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">graph_t* graph_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function declares and initializes an empty graph_t data structure. </p>
<dl class="section return"><dt>Returns</dt><dd>graph_t* </dd></dl>

</div>
</div>
<a id="a9031f7f1870c39cc2cba0aa5608058d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9031f7f1870c39cc2cba0aa5608058d8">&#9670;&nbsp;</a></span>graph_insert_edge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void graph_insert_edge </td>
          <td>(</td>
          <td class="paramtype">graph_t *&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>u</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes as input a graph_t data structure and two vertices u and v. It takes care of inserting an edge from vertex u to vertex v of the graph. <br  />
 Throws an error is the edge already exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>graph data structure. </td></tr>
    <tr><td class="paramname">u</td><td>vertex of the graph. </td></tr>
    <tr><td class="paramname">v</td><td>vertex of the graph. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e2ce4d852eac3d59f53edd8983e8c1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e2ce4d852eac3d59f53edd8983e8c1b">&#9670;&nbsp;</a></span>graph_insert_vertex()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void graph_insert_vertex </td>
          <td>(</td>
          <td class="paramtype">graph_t *&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes as input a graph_t data structure and a vertex v; it takes care of inserting the vertex v within the graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>graph data structure. </td></tr>
    <tr><td class="paramname">v</td><td>vertex to be inserted. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af05df5d8c6999573ba0e334c7f6ae513"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af05df5d8c6999573ba0e334c7f6ae513">&#9670;&nbsp;</a></span>graph_load_from_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">graph_t* graph_load_from_file </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes a string as input. It extracts a serialized graph from a file and returns a graph in the graph_t format. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>string representing the filename of the input file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9c8eef1d5e51a9ade0a654f9ad5c685b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c8eef1d5e51a9ade0a654f9ad5c685b">&#9670;&nbsp;</a></span>graph_merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void graph_merge </td>
          <td>(</td>
          <td class="paramtype">graph_t *&#160;</td>
          <td class="paramname"><em>to</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">graph_t *&#160;</td>
          <td class="paramname"><em>from</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge 2 graph and the merged graph is in graph_t * to. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to</td><td>graph with vertex index from 0 to graph_get_num_vertex(to) </td></tr>
    <tr><td class="paramname">from</td><td>graph with vertex index from 0 to graph_get_num_vertex(from) </td></tr>
    <tr><td class="paramname">p</td><td>probability of create an edge between a node of graph from and a node of graph to and viceversa </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0ed97650c201c27efbe59c6f2717504c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ed97650c201c27efbe59c6f2717504c">&#9670;&nbsp;</a></span>graph_merge_vertices()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void graph_merge_vertices </td>
          <td>(</td>
          <td class="paramtype">graph_t *&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array_int *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes as input graph, a vertex identifier 'dest' and an array of vertices. It merges all vertices in the array into the vertex 'dest'. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>graph data structure. </td></tr>
    <tr><td class="paramname">dest</td><td>a vertex identifier. </td></tr>
    <tr><td class="paramname">src</td><td>an array of vertices. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaa8e50b85caf53ed334f81361bd9c19d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa8e50b85caf53ed334f81361bd9c19d">&#9670;&nbsp;</a></span>graph_print_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void graph_print_debug </td>
          <td>(</td>
          <td class="paramtype">graph_t *&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>print on standard output graph in input: number of edged, for earch line node -&gt; adjacency list and node-&gt; inverted adjacency list </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>graph to be printed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac919cab75554fcb6dd20f1c5607c68e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac919cab75554fcb6dd20f1c5607c68e7">&#9670;&nbsp;</a></span>graph_random()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">graph_t* graph_random </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>max_n_node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mean_edges</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>variance_edges</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>create a random graph with max_n_node node and each node have mean number of edge with a variance_edge </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">max_n_node</td><td>number of node of graph </td></tr>
    <tr><td class="paramname">mean_edges</td><td>mean edge for each node </td></tr>
    <tr><td class="paramname">variance_edges</td><td>variance of number of edge for each node </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>graph_t* graph generated </dd></dl>

</div>
</div>
<a id="ae33cfb273887bd4349d2e42b4064e2d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae33cfb273887bd4349d2e42b4064e2d2">&#9670;&nbsp;</a></span>graph_save_to_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void graph_save_to_file </td>
          <td>(</td>
          <td class="paramtype">graph_t *&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes as input a graph and a string. It serializes the input graph and stores it on a binary file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>graph data structure. </td></tr>
    <tr><td class="paramname">filename</td><td>string representing the filename of the output file. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3873eaea6c1f17fa7028b7946872600d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3873eaea6c1f17fa7028b7946872600d">&#9670;&nbsp;</a></span>graph_serialize()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">array_int* graph_serialize </td>
          <td>(</td>
          <td class="paramtype">graph_t *&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">khint_t *&#160;</td>
          <td class="paramname"><em>bucket</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes as input a graph, the number of vertices to be serialized n, and a variable to store the reference to the adicence map. <br  />
 The function returns an array of integers representing the serialization of the first n vertices of the graph. <br  />
 In other words, we go from a representation using pointers to a representation that uses integers only. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>graph data structure. </td></tr>
    <tr><td class="paramname">n</td><td>number of vertices to be serialized. </td></tr>
    <tr><td class="paramname">bucket</td><td>variable to store the reference to the adicence map. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array_int* array of integers representing the serialization of the first n vertices. </dd></dl>

</div>
</div>
<a id="a7889de5b4031ad8100fa6ac37d8392f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7889de5b4031ad8100fa6ac37d8392f6">&#9670;&nbsp;</a></span>graph_tarjan()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">array_int* graph_tarjan </td>
          <td>(</td>
          <td class="paramtype">graph_t *&#160;</td>
          <td class="paramname"><em>G</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is a Tarjan's algorithm implementation using recursion. <br  />
 This is a modified version of the algorithm on the geeksforgeeks.com website. <br  />
 The main differences are: <br  />
 - disc, low and stackMember are now hash tables because we remove the hypotesis that vertex ids go from 0 to N-1: <br  />
 when working on a subgraph (as a slave process), there are no guarantees on the order nor continuity of the vertex ids. <br  />
 Using hash tables instead of arrays we save a lot of memory. <br  />
 - we remove the hypotesis that every vertex in an adjacency map exists in the graph. This is also caused by executions <br  />
 on subgraphs of a given graph. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>graph data structure. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>array_int* array containing all the found SCCs. </dd></dl>

</div>
</div>
<a id="adb71a3e52b70daf9a1f91efced7fd1a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb71a3e52b70daf9a1f91efced7fd1a5">&#9670;&nbsp;</a></span>graph_tarjan_foreach()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void graph_tarjan_foreach </td>
          <td>(</td>
          <td class="paramtype">graph_t *&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(array_int *)&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes as input a graph and a callback function f. It finds all the SCCs in the graph and each time it finds one it calls the callback function f on the SCC. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>graph data structure. </td></tr>
    <tr><td class="paramname">f</td><td>callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa167e922a8e42481edb364dd723eb3d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa167e922a8e42481edb364dd723eb3d4">&#9670;&nbsp;</a></span>graph_tarjan_foreach_helper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void graph_tarjan_foreach_helper </td>
          <td>(</td>
          <td class="paramtype">graph_t *&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">khash_t(m32) *&#160;</td>
          <td class="paramname"><em>disc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">khash_t(m32) *&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlinkedlist__int.html">linkedlist_int</a> *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">khash_t(m32) *&#160;</td>
          <td class="paramname"><em>stackMember</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array_int *&#160;</td>
          <td class="paramname"><em>scc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(array_int *)&#160;</td>
          <td class="paramname"><em>f</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is an helper function for <a class="el" href="graph_8c.html#adb71a3e52b70daf9a1f91efced7fd1a5" title="This function takes as input a graph and a callback function f. It finds all the SCCs in the graph an...">graph_tarjan_foreach()</a>. For more info see documentation for <a class="el" href="graph_8c.html#adb71a3e52b70daf9a1f91efced7fd1a5" title="This function takes as input a graph and a callback function f. It finds all the SCCs in the graph an...">graph_tarjan_foreach()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>graph data structure. </td></tr>
    <tr><td class="paramname">node</td><td>integer which represents the node. </td></tr>
    <tr><td class="paramname">stack</td><td>stack data structure. </td></tr>
    <tr><td class="paramname">time</td><td>pointer to an integer. </td></tr>
    <tr><td class="paramname">scc</td><td>array containing the SCCs. </td></tr>
    <tr><td class="paramname">f</td><td>callback function. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab67410d3c53f6f1f92908be8a90ad995"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab67410d3c53f6f1f92908be8a90ad995">&#9670;&nbsp;</a></span>graph_tarjan_helper()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void graph_tarjan_helper </td>
          <td>(</td>
          <td class="paramtype">graph_t *&#160;</td>
          <td class="paramname"><em>G</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>node</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">khash_t(m32) *&#160;</td>
          <td class="paramname"><em>disc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">khash_t(m32) *&#160;</td>
          <td class="paramname"><em>low</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structlinkedlist__int.html">linkedlist_int</a> *&#160;</td>
          <td class="paramname"><em>stack</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">khash_t(m32) *&#160;</td>
          <td class="paramname"><em>stackMember</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>time</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array_int *&#160;</td>
          <td class="paramname"><em>result</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is an helper function for <a class="el" href="graph_8c.html#a7889de5b4031ad8100fa6ac37d8392f6" title="This function is a Tarjan&#39;s algorithm implementation using recursion.   This is a modified version of...">graph_tarjan()</a>. For more info see documentation for <a class="el" href="graph_8c.html#a7889de5b4031ad8100fa6ac37d8392f6" title="This function is a Tarjan&#39;s algorithm implementation using recursion.   This is a modified version of...">graph_tarjan()</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">G</td><td>graph data structure. </td></tr>
    <tr><td class="paramname">node</td><td>pointer to an integer. </td></tr>
    <tr><td class="paramname">stack</td><td>stack data structure. </td></tr>
    <tr><td class="paramname">time</td><td>pointer to an integer. </td></tr>
    <tr><td class="paramname">result</td><td>array data structure. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="abd8bbcfabb3ddef2ccaafb9928a37b95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8bbcfabb3ddef2ccaafb9928a37b95">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int min </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>a</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>b</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function takes two integers as input and returns the minimum integer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td>first integer. </td></tr>
    <tr><td class="paramname">b</td><td>second integer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>minimum. </dd></dl>

</div>
</div>
<a id="a8549c916368233448ccf00534b504749"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8549c916368233448ccf00534b504749">&#9670;&nbsp;</a></span>scc_set_add()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scc_set_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscc__set__t.html">scc_set_t</a> *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>scc_id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">array_int *&#160;</td>
          <td class="paramname"><em>nodes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a new SCC to the set handling merges if needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>the reference to the scc_set. </td></tr>
    <tr><td class="paramname">scc_id</td><td>the id of the SCC to be added. By convention, it is the lowest among the ids of the nodes in the SCC. </td></tr>
    <tr><td class="paramname">nodes</td><td>the nodes of the SCC. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a682977e02dc5974253b0022488fe5468"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a682977e02dc5974253b0022488fe5468">&#9670;&nbsp;</a></span>scc_set_contains()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool scc_set_contains </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscc__set__t.html">scc_set_t</a> *&#160;</td>
          <td class="paramname"><em>b</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structscc__set__t.html">scc_set_t</a> *&#160;</td>
          <td class="paramname"><em>a</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check if scc set b contains all of scc set a's content. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>the first scc_set. </td></tr>
    <tr><td class="paramname">a</td><td>the second scc_set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true scc set b contains all of scc set a's content. </dd>
<dd>
false scc set b not contains all of scc set a's content. </dd></dl>

</div>
</div>
<a id="a8c6cfd0e1a260549cffd6e1dc95a48b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c6cfd0e1a260549cffd6e1dc95a48b2">&#9670;&nbsp;</a></span>scc_set_free()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scc_set_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscc__set__t.html">scc_set_t</a> *&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy an scc_set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>The scc_set to be destroyed. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a5e1742aecae1a04047d8206cc2d95c48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e1742aecae1a04047d8206cc2d95c48">&#9670;&nbsp;</a></span>scc_set_init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscc__set__t.html">scc_set_t</a>* scc_set_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initialize a new scc_set. </p>
<dl class="section return"><dt>Returns</dt><dd>scc_set_t* The scc_set </dd></dl>

</div>
</div>
<a id="a3ba807e3fbeeed224587d3a609b84b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ba807e3fbeeed224587d3a609b84b9b">&#9670;&nbsp;</a></span>scc_set_load_from_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structscc__set__t.html">scc_set_t</a>* scc_set_load_from_file </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filename</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Load scc set from file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">filename</td><td>the file to load the set from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>scc_set_t* ssc set readed </dd></dl>

</div>
</div>
<a id="a7dbb2e7d19233634bfaddc3634a43a68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dbb2e7d19233634bfaddc3634a43a68">&#9670;&nbsp;</a></span>scc_set_merge()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scc_set_merge </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscc__set__t.html">scc_set_t</a> *&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structscc__set__t.html">scc_set_t</a> *&#160;</td>
          <td class="paramname"><em>src</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge src scc_set into dest. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dest</td><td>the reference of the destination scc_set. </td></tr>
    <tr><td class="paramname">src</td><td>the reference of the source scc_set. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a74ea6f1044877da655f14a3a1ce2fb30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74ea6f1044877da655f14a3a1ce2fb30">&#9670;&nbsp;</a></span>scc_set_print_debug()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scc_set_print_debug </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscc__set__t.html">scc_set_t</a> *&#160;</td>
          <td class="paramname"><em>S</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>print an scc_set </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>ssc_set to be printed </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a403d34ed9cdcf8b1db1afb0367fb59c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a403d34ed9cdcf8b1db1afb0367fb59c9">&#9670;&nbsp;</a></span>scc_set_save_to_file()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void scc_set_save_to_file </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structscc__set__t.html">scc_set_t</a> *&#160;</td>
          <td class="paramname"><em>S</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write scc set to file. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">S</td><td>the scc_set to be saved. </td></tr>
    <tr><td class="paramname">filename</td><td>the file to be saved to. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
