<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Parallelize-Tarjan-MPI-CUDA: common_mpi/src/mpi_logic.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Parallelize-Tarjan-MPI-CUDA
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_060bbf45a54a60c2004d59c194c07adf.html">common_mpi</a></li><li class="navelem"><a class="el" href="dir_66bb36340b896c30aec1418076465299.html">src</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">mpi_logic.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file implements a version of a parallelization of Tarjan's algorithm.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;mpi.h&gt;</code><br />
<code>#include &quot;mpi_logic.h&quot;</code><br />
<code>#include &quot;measurement.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for mpi_logic.c:</div>
<div class="dyncontent">
<div class="center"><img src="mpi__logic_8c__incl.png" border="0" usemap="#acommon__mpi_2src_2mpi__logic_8c" alt=""/></div>
<map name="acommon__mpi_2src_2mpi__logic_8c" id="acommon__mpi_2src_2mpi__logic_8c">
<area shape="rect" title="This file implements a version of a parallelization of Tarjan&#39;s algorithm." alt="" coords="56,5,219,47"/>
<area shape="rect" title=" " alt="" coords="5,95,64,121"/>
<area shape="rect" title=" " alt="" coords="89,95,186,121"/>
<area shape="rect" title=" " alt="" coords="211,95,336,121"/>
</map>
</div>
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a755b505d86588dd13b5a0d5af215db4d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpi__logic_8c.html#a755b505d86588dd13b5a0d5af215db4d">callback</a> (array_int *scc)</td></tr>
<tr class="memdesc:a755b505d86588dd13b5a0d5af215db4d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a callback function. It is called every time the Tarjan'algorithm, run by a slave process on a portion of the graph, finds an scc. <br  />
 The slave process sends the found scc to the master node along with its size. <br  />
  <a href="mpi__logic_8c.html#a755b505d86588dd13b5a0d5af215db4d">More...</a><br /></td></tr>
<tr class="separator:a755b505d86588dd13b5a0d5af215db4d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4519dc9cac0f0c0e30f8718a357cad"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpi__logic_8c.html#afe4519dc9cac0f0c0e30f8718a357cad">master_schedule</a> (graph_t *graph, int N, int n_slaves, <a class="el" href="structscc__set__t.html">scc_set_t</a> *SCCs)</td></tr>
<tr class="separator:afe4519dc9cac0f0c0e30f8718a357cad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a487f136cb96d7df1937358a6a3a3e5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpi__logic_8c.html#a0a487f136cb96d7df1937358a6a3a3e5">master_work</a> (int rank, int size, char *filename, char *outputfilename)</td></tr>
<tr class="memdesc:a0a487f136cb96d7df1937358a6a3a3e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">The master node calls this function. <br  />
 The function takes as input the name of a binary file that contains a graph represented by an adjacency map. <br  />
 The master_work function takes care of extracting the contents of the binary file and converting it into a graph, then calls the <a class="el" href="mpi__logic_8c.html#a3d6bdb6c07e7023c6a252d9ae031cd6e" title="This function is called by the master node.   The function takes as input the graph and an empty set,...">master_work2()</a> function to execute the MPI algorithm.  <a href="mpi__logic_8c.html#a0a487f136cb96d7df1937358a6a3a3e5">More...</a><br /></td></tr>
<tr class="separator:a0a487f136cb96d7df1937358a6a3a3e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d6bdb6c07e7023c6a252d9ae031cd6e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpi__logic_8c.html#a3d6bdb6c07e7023c6a252d9ae031cd6e">master_work2</a> (int rank, int size, graph_t *graph, <a class="el" href="structscc__set__t.html">scc_set_t</a> *SCCs, char *outputfilename, double time_init)</td></tr>
<tr class="memdesc:a3d6bdb6c07e7023c6a252d9ae031cd6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called by the master node. <br  />
 The function takes as input the graph and an empty set, which will be filled with the scc found by Tarjan's algorithm. <br  />
 The function divides the graph into chunks of fixed size and will delegate the work to be done on the chunks to the <a class="el" href="mpi__logic_8c.html#afe4519dc9cac0f0c0e30f8718a357cad">master_schedule()</a> function. <br  />
 In addition, the function is responsible of sending the termination message to all slave processes. This happens when all the work is done.  <a href="mpi__logic_8c.html#a3d6bdb6c07e7023c6a252d9ae031cd6e">More...</a><br /></td></tr>
<tr class="separator:a3d6bdb6c07e7023c6a252d9ae031cd6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa80b6078ca0ba039351ce42580f896ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpi__logic_8c.html#aa80b6078ca0ba039351ce42580f896ec">slave_work</a> (int rank)</td></tr>
<tr class="memdesc:aa80b6078ca0ba039351ce42580f896ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function is called by the slave nodes. The function receives messages containing the portion of the graph on which the slave node must find the scc through Tarjan's algorithm. <br  />
 The function ends when a master node sends a special termination message. The termination message is a message specifying that the size of the next message is 0.  <a href="mpi__logic_8c.html#aa80b6078ca0ba039351ce42580f896ec">More...</a><br /></td></tr>
<tr class="separator:aa80b6078ca0ba039351ce42580f896ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:a13387bd68de59db8c1ae6ca4e0d82619"><td class="memItemLeft" align="right" valign="top"><a id="a13387bd68de59db8c1ae6ca4e0d82619"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>time_split_graph</b> = 0.0</td></tr>
<tr class="separator:a13387bd68de59db8c1ae6ca4e0d82619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab31d5a47c24ebad4468bc9eceb39836e"><td class="memItemLeft" align="right" valign="top"><a id="ab31d5a47c24ebad4468bc9eceb39836e"></a>
double&#160;</td><td class="memItemRight" valign="bottom"><b>time_merge_graph</b> = 0.0</td></tr>
<tr class="separator:ab31d5a47c24ebad4468bc9eceb39836e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This file implements a version of a parallelization of Tarjan's algorithm. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a755b505d86588dd13b5a0d5af215db4d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a755b505d86588dd13b5a0d5af215db4d">&#9670;&nbsp;</a></span>callback()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void callback </td>
          <td>(</td>
          <td class="paramtype">array_int *&#160;</td>
          <td class="paramname"><em>scc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This is a callback function. It is called every time the Tarjan'algorithm, run by a slave process on a portion of the graph, finds an scc. <br  />
 The slave process sends the found scc to the master node along with its size. <br  />
 </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scc</td><td>It is the scc discovered from the Tarjan's algorithm. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="afe4519dc9cac0f0c0e30f8718a357cad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4519dc9cac0f0c0e30f8718a357cad">&#9670;&nbsp;</a></span>master_schedule()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void master_schedule </td>
          <td>(</td>
          <td class="paramtype">graph_t *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>N</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>n_slaves</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structscc__set__t.html">scc_set_t</a> *&#160;</td>
          <td class="paramname"><em>SCCs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The function takes as input the graph, the size of the chunk, the number of slave processes and the data structure where to save all the scc found. <br  />
 The function sends a chunk of the graph to each slave node. Then, it waits for the slave nodes to find the scc by applying Tarjan's algorithm on their chunk of the graph. As soon as a slave node finishes execution, the master node assigns it another chunk of the graph. <br  />
 The iterations terminate as soon as the whole graph for the fixed chunk size has been completed by the slave nodes.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">graph</td><td>graph on which compute all the scc. </td></tr>
    <tr><td class="paramname">N</td><td>represents the chunk size. </td></tr>
    <tr><td class="paramname">n_slaves</td><td>number of slave precesses. </td></tr>
    <tr><td class="paramname">SCCs</td><td>data structure where to save all the scc found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0a487f136cb96d7df1937358a6a3a3e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a487f136cb96d7df1937358a6a3a3e5">&#9670;&nbsp;</a></span>master_work()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void master_work </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>outputfilename</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The master node calls this function. <br  />
 The function takes as input the name of a binary file that contains a graph represented by an adjacency map. <br  />
 The master_work function takes care of extracting the contents of the binary file and converting it into a graph, then calls the <a class="el" href="mpi__logic_8c.html#a3d6bdb6c07e7023c6a252d9ae031cd6e" title="This function is called by the master node.   The function takes as input the graph and an empty set,...">master_work2()</a> function to execute the MPI algorithm. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>id of the process within the communicator. </td></tr>
    <tr><td class="paramname">size</td><td>size of the communicator. </td></tr>
    <tr><td class="paramname">filename</td><td>name of the file that contains a graph represented by an adjacency map. </td></tr>
    <tr><td class="paramname">outputfilename</td><td>name of the output binary file that will contain all the scc found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3d6bdb6c07e7023c6a252d9ae031cd6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d6bdb6c07e7023c6a252d9ae031cd6e">&#9670;&nbsp;</a></span>master_work2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void master_work2 </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">graph_t *&#160;</td>
          <td class="paramname"><em>graph</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structscc__set__t.html">scc_set_t</a> *&#160;</td>
          <td class="paramname"><em>SCCs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>outputfilename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>time_init</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called by the master node. <br  />
 The function takes as input the graph and an empty set, which will be filled with the scc found by Tarjan's algorithm. <br  />
 The function divides the graph into chunks of fixed size and will delegate the work to be done on the chunks to the <a class="el" href="mpi__logic_8c.html#afe4519dc9cac0f0c0e30f8718a357cad">master_schedule()</a> function. <br  />
 In addition, the function is responsible of sending the termination message to all slave processes. This happens when all the work is done. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>id of the process within the communicator. </td></tr>
    <tr><td class="paramname">size</td><td>size of the communicator. </td></tr>
    <tr><td class="paramname">graph</td><td>graph that will be computed in order to find its sccs. </td></tr>
    <tr><td class="paramname">SCCs</td><td>empty set which will be filled with the scc found by Tarjan's algorithm. </td></tr>
    <tr><td class="paramname">outputfilename</td><td>name of the output binary file that will contain all the scc found. </td></tr>
    <tr><td class="paramname">time_init</td><td>initialization time. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa80b6078ca0ba039351ce42580f896ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa80b6078ca0ba039351ce42580f896ec">&#9670;&nbsp;</a></span>slave_work()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void slave_work </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rank</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function is called by the slave nodes. The function receives messages containing the portion of the graph on which the slave node must find the scc through Tarjan's algorithm. <br  />
 The function ends when a master node sends a special termination message. The termination message is a message specifying that the size of the next message is 0. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rank</td><td>id of the process within the communicator. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
